"""Functions to randomly generate nidi."""

from scipy.special import comb
import networkx as nx
import random
import avm
import math
import numpy as np

def lerp(x, a, b, c, d):
    """Computes the linear interpolation between c and d, based on the relative position of x between a and b."""
    return c + (d - c) * (x - a) / (b - a)

def normint(a, b, mean = None, sd = None) -> float:
    """Generates a random integer within the range [a, b], drawn from a normal distribution characterized by a specified mean and standard deviation. The function repeatedly samples from the normal distribution until an integer falling within the specified range is obtained."""
    mean = mean if mean is not None else (a + b) / 2
    sd = sd if sd is not None else (b - mean) / 3
    while True:
        i = round(random.normalvariate(mean, sd))
        if (a is None or i >= a) and (b is None or i <= b): return i

def norm(a, b, mean = None, sd = None) -> float:
    """Generates a random number within the range [a, b], drawn from a normal distribution characterized by a specified mean and standard deviation. The function repeatedly samples from the normal distribution until an number falling within the specified range is obtained."""
    mean = mean if mean is not None else (a + b) / 2
    sd = sd if sd is not None else (b - mean) / 3
    while True:
        i = random.normalvariate(mean, sd)
        if (a is None or i >= a) and (b is None or i <= b): return i

def choose_norm(list, mean, sd):
    """Selects an element from list using an index generated by normint, which draws from a normal distribution with a specified mean and standard deviation. The index is constrained between 0 and the length of the list minus one, ensuring a valid element from the list is chosen."""
    index = normint(0, len(list) - 1, mean, sd)
    return index, list[index]

# MEAN_PLEXIFORM_RADIUS, MEAN_PLEXIFORM_LENGTH, MEAN_FISTULOUS_RADIUS, and MEAN_FISTULOUS_LENGTH are all measured in cm.
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7390970/ says radius is about 50 microns
# https://www.sciencedirect.com/science/article/pii/S1078588417307360 says diameter is 265 microns
# https://sci-hubtw.hkvisa.net/10.1111/j.1440-1827.1981.tb02813.x is the og source that says diameter 265 microns
# https://journals.sagepub.com/doi/epdf/10.1097/00004647-199708000-00009?src=getftr this paper explains that they artificially increased the resistances to account for the resistance lost by approximating the curved vessels as straight
MEAN_PLEXIFORM_RADIUS = 0.011
def random_plexiform_radius() -> float:
    return MEAN_PLEXIFORM_RADIUS
    # return norm(0.01, None, MEAN_PLEXIFORM_RADIUS, (MEAN_PLEXIFORM_RADIUS - 0.01) / 3)

# https://www.sciencedirect.com/science/article/pii/S1350453398000599 says 5 mm as length
MEAN_PLEXIFORM_LENGTH = 0.05  # No source, 1996 paper had no source either
def random_plexiform_length() -> float:
    return MEAN_PLEXIFORM_LENGTH
    # return norm(0.01, None, MEAN_PLEXIFORM_LENGTH, (MEAN_PLEXIFORM_LENGTH - 0.01) / 3)

print(avm.calc_resistance(MEAN_PLEXIFORM_RADIUS, MEAN_PLEXIFORM_LENGTH))

# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9537653/ fistulas with diameter 200 microns
MEAN_FISTULOUS_RADIUS = MEAN_PLEXIFORM_RADIUS * 2
def random_fistulous_radius() -> float:
    return MEAN_FISTULOUS_RADIUS
    # return norm(0.01, None, MEAN_FISTULOUS_RADIUS, (MEAN_FISTULOUS_RADIUS - 0.01) / 3)

MEAN_FISTULOUS_LENGTH = 0.05
def random_fistulous_length() -> float:
    return MEAN_FISTULOUS_LENGTH
    # return norm(0.01, None, MEAN_FISTULOUS_LENGTH, (MEAN_FISTULOUS_LENGTH - 0.01) / 3)

def two_connections(graph: nx.Graph, intranidal_nodes: list, plexiform_resistance: float = 81600) -> nx.Graph:
    """Generates a new graph with a random nidus from a given graph and its intranidal nodes by going through each node and connecting it to two other new intranidal nodes.

    Args:
        graph: The original graph.
        intranidal_nodes: List of the nodes between which to generate edges.
        num_expected_edges: Expected number of edges to generate.

    Returns:
        graph: The graph with a random nidus formation.
    """
    num_intranidal_verts = len(intranidal_nodes)
    for j in range(num_intranidal_verts - 1):
        for i in range(2):
            unconnected = [node for node in intranidal_nodes if not graph.has_edge(intranidal_nodes[j], node) and node is not intranidal_nodes[j]]
            node = random.choice(unconnected)
            avm.add_edge_to_graph(graph, intranidal_nodes[j], node, 0.05, 5, plexiform_resistance if avm.PREDEFINED_RESISTANCE else avm.calc_resistance(0.05, 0.5))
    return graph

def stochastic(graph: nx.Graph, intranidal_nodes: list, sizes: list[int], p: list[list[float]], plexiform_resistance: float = 81600) -> nx.Graph:
    """Generates a new graph with a random nidus from a given graph and its intranidal nodes with a stochastic block model

    Args:
        graph: The original graph.
        intranidal_nodes: List of the nodes between which to generate edges.
        sizes: List of block sizes (see NetworkX's stochastic_block_model).
        p: Stochastic matrix (see NetworkX's stochastic_block_model).

    Returns:
        graph: The graph with a random nidus formation.
    """
    random_graph = nx.stochastic_block_model(sizes, p, intranidal_nodes)
    for edge in random_graph.edges:
            radius, length = 0.05, 5
            avm.add_edge_to_graph(edge[0], edge[1], radius, length, plexiform_resistance if avm.PREDEFINED_RESISTANCE else avm.calc_resistance(radius, length))
    return graph

def linear(graph: nx.Graph, intranidal_nodes: list, plexiform_resistance: float = 81600) -> nx.Graph:
    """Generates a new graph from a given graph and its intranidal nodes by connecting the intranidal nodes in a single path.

    Args:
        graph: The original graph.
        intranidal_nodes: List of the nodes between which to generate edges.

    Returns:
        graph: The graph with a nidus formation.
    """
    for n1, n2 in zip(intranidal_nodes[:-1], intranidal_nodes[1:]):
        radius, length = 0.05, 5
        avm.add_edge_to_graph(graph, n1, n2, radius, length, plexiform_resistance if avm.PREDEFINED_RESISTANCE else avm.calc_resistance(radius, length))
    return graph

def gilbert(graph: nx.Graph, intranidal_nodes: list, num_expected_edges: int, plexiform_resistance: float = 81600) -> nx.Graph:
    """Generates a new graph with a random nidus from a given graph and its intranidal nodes.

    Args:
        graph: The original graph.
        intranidal_nodes: List of the nodes between which to generate edges.
        num_expected_edges: Expected number of edges to generate.

    Returns:
        graph: The graph with a random nidus formation.
    """
    num_intranidal_verts = len(intranidal_nodes)
    probability = num_expected_edges / comb(num_intranidal_verts, 2)
    for j in range(num_intranidal_verts - 1):
        for k in range(j + 1, num_intranidal_verts):
            if random.random() < probability:
                # radius, length = random.normalvariate(0.05, 0.01), random.normalvariate(5, 1)
                radius, length = 0.05, 5
                avm.add_edge_to_graph(graph, intranidal_nodes[j], intranidal_nodes[k], radius, length, plexiform_resistance if avm.PREDEFINED_RESISTANCE else avm.calc_resistance(radius, length))
    return graph

def compartments(graph: nx.Graph, feeders: list, drainers: list, first_intranidal_id: int, node_pos: dict, num_compartments: int, num_columns: int, num_cross_compartment_vessels: int = 20, fistula_start = "AF2", fistula_end = "DV2", spacing: float = 3) -> tuple[nx.Graph, list[list[list]]]:
    """"""
    # Generate configuration
    # At first, columns[i][j] is the number of nodes in the `i`th column that are in the `j`th compartment
    # After calculating node positions, columns[i][j][k] is the id of the `k`th node in S, where S is the set of nodes in the `i`th column that are in the `j`th compartment
    columns = [[] for i in range(num_columns)]
    for j in range(num_compartments):
        min_compartment_height = normint(30, 34)
        max_compartment_height = normint(36, 40)
        indices = np.linspace(-3, 3, num_columns)
        values = min_compartment_height + (max_compartment_height - min_compartment_height) * np.exp(-np.power(indices, 2))
        compartment = [normint(value * 0.8, value + 2, value) for value in values]
        for i in range(num_columns):
            columns[i].append(compartment[i])
    
    # Calculate node positions
    left = bottom = float("inf")
    right = top = float("-inf")
    for node in drainers + feeders:
        left = min(node_pos[node][0], left)
        right = max(node_pos[node][0], right)
        bottom = min(node_pos[node][1], bottom)
        top = max(node_pos[node][1], top)
    
    node_id = first_intranidal_id
    for i, column in enumerate(columns):
        height = sum(column) + (num_compartments - 1) * spacing  # The height (in number of nodes) of the column
        y = 0
        for j, compartment in enumerate(column):
            compartment_nodes = []
            for _ in range(compartment):
                node_pos[node_id] = [lerp(i, -1, len(columns), left, right), lerp(y, -spacing * 3, height - spacing, top, bottom)]
                compartment_nodes.append(node_id)
                y += 1
                node_id += 1
            columns[i][j] = compartment_nodes
            y += spacing
    
    # Generate intranidal vessels
    for i, column in enumerate(columns[:-1]):
        for j in range(num_compartments):
            small, large = (columns[i][j], columns[i + 1][j].copy()) if len(columns[i][j]) < len(columns[i + 1][j]) else (columns[i + 1][j], columns[i][j].copy())
            for node in small:
                partner = random.choice(large)
                large.remove(partner)
                switched = node in columns[i + 1][j]
                avm.add_edge_to_graph(graph, partner if switched else node, node if switched else partner, random_plexiform_radius(), random_plexiform_length())
            for node in large:
                partner = random.choice(small)
                switched = node in columns[i + 1][j]
                avm.add_edge_to_graph(graph, partner if switched else node, node if switched else partner, random_plexiform_radius(), random_plexiform_length())

    # Generate vessels that connect the feeders/drainers to nidus
    afs_left = feeders.copy()
    for i in range(first_intranidal_id, first_intranidal_id + sum([len(a) for a in columns[0]])):
        nearest, nearest_d = "AF1", (node_pos["AF1"][0] - node_pos[i][0]) ** 2 + (node_pos["AF1"][1] - node_pos[i][1]) ** 2
        for feeder in feeders[1:]:
            d = (node_pos[feeder][0] - node_pos[i][0]) ** 2 + (node_pos[feeder][1] - node_pos[i][1]) ** 2
            if d < nearest_d:
                nearest = feeder
                nearest_d = d
        if nearest in afs_left: afs_left.remove(nearest)
        avm.add_edge_to_graph(graph, nearest, i, random_plexiform_radius(), random_plexiform_length())
    dvs_left = drainers.copy()
    for i in range(node_id - sum([len(a) for a in columns[-1]]), node_id):
        nearest, nearest_d = "DV1", (node_pos["DV1"][0] - node_pos[i][0]) ** 2 + (node_pos["DV1"][1] - node_pos[i][1]) ** 2
        for drainer in drainers[1:]:
            d = (node_pos[drainer][0] - node_pos[i][0]) ** 2 + (node_pos[drainer][1] - node_pos[i][1]) ** 2
            if d < nearest_d:
                nearest = drainer
                nearest_d = d
        if nearest in dvs_left: dvs_left.remove(nearest)
        avm.add_edge_to_graph(graph, i, nearest, random_plexiform_radius(), random_plexiform_length())
    for af in afs_left:
        nearest, nearest_d = 0, float('inf')
        for i in range(first_intranidal_id, node_id):
            d = (node_pos[af][0] - node_pos[i][0]) ** 2 + (node_pos[af][1] - node_pos[i][1]) ** 2
            if d < nearest_d:
                nearest = i
                nearest_d = d
        avm.add_edge_to_graph(graph, af, nearest, random_plexiform_radius(), random_plexiform_length())
    for dv in dvs_left:
        nearest, nearest_d = 0, float('inf')
        for i in range(first_intranidal_id, node_id):
            d = (node_pos[dv][0] - node_pos[i][0]) ** 2 + (node_pos[dv][1] - node_pos[i][1]) ** 2
            if d < nearest_d:
                nearest = i
                nearest_d = d
        avm.add_edge_to_graph(graph, nearest, dv, random_plexiform_radius(), random_plexiform_length())
    
    # Generate cross-compartment vesels
    if num_compartments > 1:
        for _ in range(num_cross_compartment_vessels):
            start_col = random.randint(0, num_columns - 2)
            start_compartment = random.randint(0, num_compartments - 1)
            start_node_id = random.choice(columns[start_col][start_compartment])
            end_col = start_col
            while end_col == start_col:
                end_col = normint(0, num_columns - 1, start_col, 2)
            # end_col = random.choice([i for i in range(num_columns) if i != start_col])
            end_compartment = random.choice([i for i in range(num_compartments) if i != start_compartment])
            end_node_id = random.choice(columns[end_col][end_compartment])
            avm.add_edge_to_graph(graph, start_node_id, end_node_id, random_plexiform_radius(), random_plexiform_length())
    
    # Generate the fistulous vessels as a continuous path through the nidus
    compartment = num_compartments // 2
    start_id, start_index = fistula_start, 0
    for i in range(num_columns):
        if i == 0:
            end_index = random.randint(0, len(columns[0][compartment]) - 1)
            avm.add_edge_to_graph(graph, start_id, columns[0][compartment][end_index], random_fistulous_radius(), random_fistulous_length(), type = avm.vessel.fistulous)
            start_index = end_index
        else:
            start_id = columns[i - 1][compartment][start_index]
            end_index, end_node_id = choose_norm(columns[i][compartment], lerp(start_index, 0, len(columns[i - 1][compartment]) - 1, 0, len(columns[i][compartment]) - 1), 2)
            avm.add_edge_to_graph(graph, start_id, end_node_id, random_fistulous_radius(), random_fistulous_length(), type = avm.vessel.fistulous)
            start_index = end_index
    avm.add_edge_to_graph(graph, columns[-1][compartment][start_index], fistula_end, random_fistulous_radius(), random_fistulous_length(), type = avm.vessel.fistulous)
    
    return graph, columns

